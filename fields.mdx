---
title: "Fields"
description: "To implement Dromo in your application, you must first define a schema. A schema is an array of field objects. These fields will be matched to columns during the import process, and define the properties of the JSON payload passed back in the results."
icon: "text"
---

## Basics[​](#basics "Direct link to Basics")

The most basic field consists of only a `key` and `label`. The field's key is its unique identifier, and will be the key of that field in the result JSON object. The field's label is how it will be displayed to the user.

* Schema
* Review screen
* Results

A basic schema could look like this:

<CodeGroup>
```javascript
fields: [
  {
    label: "First name",
    key: "firstName"
  },
  {
    label: "Last name",
    key: "lastName"
  },
  {
    label: "Membership ID",
    key: "memberId"
  }
]
```
</CodeGroup>

The user would then match these fields to the columns in their imported file, resulting in a review screen which looks like this:

![The review screen with data](\images\assets\images\basicFields_review-23cd9388ebca4f4b5e251dee170cd47f.png)

And, when submitted, Dromo would provide you with a result data array like this:

<CodeGroup>
```json
[
  {
    "firstName": "Richard",
    "lastName": "Wysocki",
    "memberId": "38008"
  },
  {
    "firstName": "Paige",
    "lastName": "Pierce",
    "memberId": "29190"
  },
  {
    "firstName": "Paul",
    "lastName": "McBeth",
    "memberId": "27523"
  },
  {
    "firstName": "Kristin",
    "lastName": "Tattar",
    "memberId": "73986"
  },
  {
    "firstName": "Calvin",
    "lastName": "Heimburg",
    "memberId": "45971"
  },
  {
    "firstName": "Catrina",
    "lastName": "Allen",
    "memberId": "44184"
  },
  {
    "firstName": "Eagle",
    "lastName": "McMahon",
    "memberId": "37817"
  }
]
```
</CodeGroup>

## Field object reference[​](#field-object-reference "Direct link to Field object reference")

<ResponseField name="label" type="string" required>
  The human-friendly name of the field, shown to the user in the Dromo Uploader interface
</ResponseField>

<ResponseField name="key" type="string" required>
  The field's unique identifier, used as the key in the JSON results
</ResponseField>

<ResponseField name="type" type="FieldType" default="string">
  The field's type.

  Can be supplied in two formats:

  * As a string corresponding to a valid field type. If the field type accepts options, defaults will be used.
  * For field types which accept options, as a two element array where the first element is the string corresponding to a valid field type, and the second element is an object with type options.

  For more details, see [field types](/fields/field-types).
</ResponseField>

<ResponseField name="description" type="string">
  An optional description of this field for the user. If you specify a value for this field, Dromo will show a ? icon in the importer that users can hover over to see this message.
</ResponseField>

<ResponseField name="alternateMatches" type="string[]">
  An array of alternate matches that this field to map to. See [column matching](#column-matching).
</ResponseField>

<ResponseField name="validators" type="Validator[]">
  An array of validator objects to validate this field. See [validators](#validators).
</ResponseField>

<ResponseField name="selectOptions" type="{ label: string, value: string, alternateMatches?: string[] }[]">
  For select fields only, an array of possible picklist values. See the [select field type](#select).
</ResponseField>

<ResponseField name="readOnly" type="boolean" default="false">
  If `true`, the user will not be able to edit the data in this field.

  This is useful if you want to exclusively populate a virtual field using hooks.
</ResponseField>

<ResponseField name="hidden" type="boolean" default="false">
  If `true`, the field will be hidden from the user at all times. A hidden field can be set only using hooks.

  A user will not be able to match a column of data to the field. A user will not see the field in the review screen. The field will only be added to the submitted final result.

  Since a user cannot change the value of a hidden field, no validations can be set on a hidden field.
</ResponseField>

<ResponseField name="requireMapping" type="boolean" default="false">
  If `true`, the field must be mapped when matching columns. The user will not be able to progress to the data review screen unless this field has been matched to a column in the input file.

  Note: cells in this column aren't required to have any values, that can be validated using [the validator `required`](/fields#required).
</ResponseField>

<ResponseField name="manyToOne" type="boolean" default="false">
  If `true`, the field may have multiple data columns mapped to it.

  The result payload will have an array of all mapped columns' values instead of just a single value. Row hooks will have an entry in a `manyToOne` array for each mapped column.
</ResponseField>

## Validators[​](#validators "Direct link to Validators")

Indepedent of field types, Dromo provides a number of validators that you can use to ensure that get clean data in exactly the format you want them. You can use validators to highlight errors for the user and ensure that they fix the errors before submitting an import.

You can specify validators for a field by providing the `validators` parameter, which takes an array of validator objects.

Each object must have a `validate` parameter which specifies what kind of validation it is. Every validator takes an optional `errorMessage` which you can use to provide a customized error message to the user when the validation fails. The error message is shown to the user as a tooltip on invalid cells.

![A validator error message shown to the user](\images\assets\images\validator_error-d3ca93911f5e533aad98c68e9fe0b339.png)

Dromo provides the following validators.

### Required[​](#required "Direct link to Required")

<ResponseField name="validate" type='"required"' required>
  Specifies that the field cannot be empty.
</ResponseField>

<ResponseField name="errorMessage" type="string">
  Custom error message to display when validation fails.
</ResponseField>

### Unique[​](#unique "Direct link to Unique")

<ResponseField name="validate" type='"unique" | "unique_case_insensitive"' required>
  Specifies that all non-empty values in the column must be distinct (non-equal).

  You can also validate uniqueness case-insensitively with `{ validate: "unique_case_insensitive" }`.
</ResponseField>

<ResponseField name="errorMessage" type="string">
  Custom error message to display when validation fails.
</ResponseField>

### Unique across multiple fields[​](#unique-across-multiple-fields "Direct link to Unique across multiple fields")

<ResponseField name="validate" type='"unique_with"' required>
  The `unique_with` validator can be used to validate uniqueness across multiple fields.
</ResponseField>

<ResponseField name="uniqueKey" type="string" required>
  A unique identifier shared across all fields that should be validated together for uniqueness.
</ResponseField>

<ResponseField name="errorMessage" type="string">
  Custom error message to display when validation fails.
</ResponseField>

The `unique_with` validator can be used to validate uniqueness across multiple fields.

To use it, place a `unique_with` validator on each field that you want to be part of the uniqueness validation, all sharing the same `uniqueKey`.

Here is an example set of fields using `unique_with` validators used to validate that the combination of the first name and last name fields are unique.

<CodeGroup>
```javascript
[
  {
    label: "First Name",
    key: "firstName",
    validators: [
      {
        validate: "unique_with",
        uniqueKey: "full name",
      },
    ],
  },
  {
    label: "Last Name",
    key: "lastName",
    validators: [
      {
        validate: "unique_with",
        uniqueKey: "full name",
      },
    ],
  },
]
```
</CodeGroup>

And here is an example of the validators in action:

![](\images\assets\images\unique_with_example-1c91bd7d7d02a081ea2980233bb915a5.png)

### Matches a regular expression[​](#matches-a-regular-expression "Direct link to Matches a regular expression")

<ResponseField name="validate" type='"regex_match" | "regex_exclude"' required>
  You can validate that a field matches the given regular expression with the `regex_match` validator.

  Conversely, you can validate that a field does *not* match a regular expression with the `regex_exclude` validator.
</ResponseField>

<ResponseField name="regex" type="string | RegExp" required>
  The regular expression pattern to match against.
</ResponseField>

<ResponseField name="regexOptions" type="RegexOptions">
  Optional regex configuration options.
</ResponseField>

<ResponseField name="errorMessage" type="string">
  Custom error message to display when validation fails.
</ResponseField>

The Dromo uploader uses standard JavaScript regular expressions. You can set the `regex` key as either a `RegExp` literal/object or a string.

If you choose to use a string, be careful to properly escape special characters in your regex. For example, the regex `/^"\d+"$/` should be passed in as `"^\"\\d+\"$"`. Additionally, if using a string, note that you cannot pass in regex flags directly in your regex. Instead, you may optionally provide a `regexOptions` parameter with the validator which takes an object with the following keys:

* `ignoreCase: boolean` - Case insensitive flag (regex flag `i`)
* `dotAll: boolean` - Matches all including any line breaks (regex flag `s`)
* `multiline: boolean` - Multiline flag (regex flag `m`)
* `unicode: boolean` - Unicode flag (regex flag `u`)

### Require with other fields[​](#require-with-other-fields "Direct link to Require with other fields")

<ResponseField name="validate" type='"require_with" | "require_without" | "require_with_all" | "require_without_all"' required>
  You can use these validators to require that a field be non-empty *only if* other fields are present or empty. There are four variations.
</ResponseField>

<ResponseField name="fields" type="string[]" required>
  Array of field keys to check against.
</ResponseField>

<ResponseField name="errorMessage" type="string">
  Custom error message to display when validation fails.
</ResponseField>

You can use these validators to require that a field be non-empty *only if* other fields are present or empty. There are four variations:

> `{ validate: "require_with", fields: [<fieldKey>, ...] }`

This will require that the field has a value if **any** of the fields listed in the `fields` array are **non-empty**.

> `{ validate: "require_without", fields: [<fieldKey>, ...] }`

This will require that the field has a value if **any** of the fields listed in the `fields` array are **empty**.

> `{ validate: "require_with_all", fields: [<fieldKey>, ...] }`

This will require that the field has a value if **all** of the fields listed in the `fields` array are **non-empty**.

> `{ validate: "require_without_all", fields: [<fieldKey>, ...] }`

This will require that the field has a value if **all** of the fields listed in the `fields` array are **empty**.

### Require with other field values[​](#require-with-other-field-values "Direct link to Require with other field values")

<ResponseField name="validate" type='"require_with_values" | "require_without_values" | "require_with_all_values" | "require_without_all_values"' required>
  You can use these validators to require that a field be non-empty *only if* other fields have specific values. There are four variations.
</ResponseField>

<ResponseField name="fieldValues" type="{ [fieldKey: string]: string }" required>
  Object mapping field keys to their required values.
</ResponseField>

<ResponseField name="errorMessage" type="string">
  Custom error message to display when validation fails.
</ResponseField>

You can use these validators to require that a field be non-empty *only if* other fields have specific values. There are four variations:

> `{ validate: "require_with_values", fieldValues: { <fieldKey>: <fieldValue>, ... } }`

This will require that the field has a value if **any** of the fields contain the corresponding value specified under `fieldValues`.

> `{ validate: "require_without_values", fieldValues: { <fieldKey>: <fieldValue>, ... } }`

This will require that the field has a value if **any** of the fields **do not** contain the corresponding value specified under `fieldValues`.

> `{ validate: "require_with_all_values", fieldValues: { <fieldKey>: <fieldValue>, ... } }`

This will require that the field has a value if **all** of the fields contain the corresponding value specified under `fieldValues`.

> `{ validate: "require_without_all_values", fieldValues: { <fieldKey>: <fieldValue>, ... } }`

This will require that the field has a value if **all** of the fields **do not** contain the corresponding value specified under `fieldValues`.

### Length[​](#length "Direct link to Length")

<ResponseField name="validate" type='"length"' required>
  Validates that a field's value falls within a minimum or maximum number of characters.

  Either min, max, or both must be defined. Values are inclusive.

  The length validator cannot be used with non-string-based fields, such as number or date fields.
</ResponseField>

<ResponseField name="min" type="number">
  Minimum number of characters allowed.
</ResponseField>

<ResponseField name="max" type="number">
  Maximum number of characters allowed.
</ResponseField>

<ResponseField name="errorMessage" type="string">
  Custom error message to display when validation fails.
</ResponseField>

### Alphabetical[​](#alphabetical "Direct link to Alphabetical")

<ResponseField name="validate" type='"alphabetical"' required>
  Validates that a field's value only contains alphabetical characters (a-z, lowercase and uppercase).
</ResponseField>

<ResponseField name="errorMessage" type="string">
  Custom error message to display when validation fails.
</ResponseField>

## Column matching[​](#column-matching "Direct link to Column matching")

During the column matching step, Dromo will try to match columns headers in the user data to a corresponding `label` or `key` within your fields.

If you want to provide additional aliases that should automatically match to a given field, you can do so by setting `alternateMatches` for that field.

Column matching is case-sensitive.

Example:

<CodeGroup>
```javascript
{
  label: "City",
  key: "city",
  alternateMatches: ["municipality", "town", "locality"]
}
```
</CodeGroup>
